import {
  __publicField
} from "./chunk-V6TY7KAL.js";

// node_modules/fireworks-js/dist/index.es.js
function f(e) {
  return Math.abs(Math.floor(e));
}
function c(e, t) {
  return Math.random() * (t - e) + e;
}
function o(e, t) {
  return Math.floor(c(e, t + 1));
}
function m(e, t, i, s) {
  const n = Math.pow;
  return Math.sqrt(n(e - i, 2) + n(t - s, 2));
}
function x(e, t, i = 1) {
  if (e > 360 || e < 0)
    throw new Error(`Expected hue 0-360 range, got \`${e}\``);
  if (t > 100 || t < 0)
    throw new Error(`Expected lightness 0-100 range, got \`${t}\``);
  if (i > 1 || i < 0)
    throw new Error(`Expected alpha 0-1 range, got \`${i}\``);
  return `hsla(${e}, 100%, ${t}%, ${i})`;
}
var g = (e) => {
  if (typeof e == "object" && e !== null) {
    if (typeof Object.getPrototypeOf == "function") {
      const t = Object.getPrototypeOf(e);
      return t === Object.prototype || t === null;
    }
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  return false;
};
var y = [
  "__proto__",
  "constructor",
  "prototype"
];
var v = (...e) => e.reduce((t, i) => (Object.keys(i).forEach((s) => {
  y.includes(s) || (Array.isArray(t[s]) && Array.isArray(i[s]) ? t[s] = i[s] : g(t[s]) && g(i[s]) ? t[s] = v(t[s], i[s]) : t[s] = i[s]);
}), t), {});
function b(e, t) {
  let i;
  return (...s) => {
    i && clearTimeout(i), i = setTimeout(() => e(...s), t);
  };
}
var S = class {
  constructor({
    x: t,
    y: i,
    ctx: s,
    hue: n,
    decay: h,
    gravity: a,
    friction: r,
    brightness: u,
    flickering: p,
    lineWidth: l,
    explosionLength: d
  }) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "ctx");
    __publicField(this, "hue");
    __publicField(this, "friction");
    __publicField(this, "gravity");
    __publicField(this, "flickering");
    __publicField(this, "lineWidth");
    __publicField(this, "explosionLength");
    __publicField(this, "angle");
    __publicField(this, "speed");
    __publicField(this, "brightness");
    __publicField(this, "coordinates", []);
    __publicField(this, "decay");
    __publicField(this, "alpha", 1);
    for (this.x = t, this.y = i, this.ctx = s, this.hue = n, this.gravity = a, this.friction = r, this.flickering = p, this.lineWidth = l, this.explosionLength = d, this.angle = c(0, Math.PI * 2), this.speed = o(1, 10), this.brightness = o(u.min, u.max), this.decay = c(h.min, h.max); this.explosionLength--; )
      this.coordinates.push([t, i]);
  }
  update(t) {
    this.coordinates.pop(), this.coordinates.unshift([this.x, this.y]), this.speed *= this.friction, this.x += Math.cos(this.angle) * this.speed, this.y += Math.sin(this.angle) * this.speed + this.gravity, this.alpha -= this.decay, this.alpha <= this.decay && t();
  }
  draw() {
    const t = this.coordinates.length - 1;
    this.ctx.beginPath(), this.ctx.lineWidth = this.lineWidth, this.ctx.fillStyle = x(this.hue, this.brightness, this.alpha), this.ctx.moveTo(
      this.coordinates[t][0],
      this.coordinates[t][1]
    ), this.ctx.lineTo(this.x, this.y), this.ctx.strokeStyle = x(
      this.hue,
      this.flickering ? c(0, this.brightness) : this.brightness,
      this.alpha
    ), this.ctx.stroke();
  }
};
var E = class {
  constructor(t, i) {
    __publicField(this, "active", false);
    __publicField(this, "x");
    __publicField(this, "y");
    this.options = t, this.canvas = i, this.pointerDown = this.pointerDown.bind(this), this.pointerUp = this.pointerUp.bind(this), this.pointerMove = this.pointerMove.bind(this);
  }
  get mouseOptions() {
    return this.options.mouse;
  }
  mount() {
    this.canvas.addEventListener("pointerdown", this.pointerDown), this.canvas.addEventListener("pointerup", this.pointerUp), this.canvas.addEventListener("pointermove", this.pointerMove);
  }
  unmount() {
    this.canvas.removeEventListener("pointerdown", this.pointerDown), this.canvas.removeEventListener("pointerup", this.pointerUp), this.canvas.removeEventListener("pointermove", this.pointerMove);
  }
  usePointer(t, i) {
    const { click: s, move: n } = this.mouseOptions;
    (s || n) && (this.x = t.pageX - this.canvas.offsetLeft, this.y = t.pageY - this.canvas.offsetTop, this.active = i);
  }
  pointerDown(t) {
    this.usePointer(t, this.mouseOptions.click);
  }
  pointerUp(t) {
    this.usePointer(t, false);
  }
  pointerMove(t) {
    this.usePointer(t, this.active);
  }
};
var O = class {
  constructor() {
    __publicField(this, "hue");
    __publicField(this, "rocketsPoint");
    __publicField(this, "opacity");
    __publicField(this, "acceleration");
    __publicField(this, "friction");
    __publicField(this, "gravity");
    __publicField(this, "particles");
    __publicField(this, "explosion");
    __publicField(this, "mouse");
    __publicField(this, "boundaries");
    __publicField(this, "sound");
    __publicField(this, "delay");
    __publicField(this, "brightness");
    __publicField(this, "decay");
    __publicField(this, "flickering");
    __publicField(this, "intensity");
    __publicField(this, "traceLength");
    __publicField(this, "traceSpeed");
    __publicField(this, "lineWidth");
    __publicField(this, "lineStyle");
    __publicField(this, "autoresize");
    this.autoresize = true, this.lineStyle = "round", this.flickering = 50, this.traceLength = 3, this.traceSpeed = 10, this.intensity = 30, this.explosion = 5, this.gravity = 1.5, this.opacity = 0.5, this.particles = 50, this.friction = 0.95, this.acceleration = 1.05, this.hue = {
      min: 0,
      max: 360
    }, this.rocketsPoint = {
      min: 50,
      max: 50
    }, this.lineWidth = {
      explosion: {
        min: 1,
        max: 3
      },
      trace: {
        min: 1,
        max: 2
      }
    }, this.mouse = {
      click: false,
      move: false,
      max: 1
    }, this.delay = {
      min: 30,
      max: 60
    }, this.brightness = {
      min: 50,
      max: 80
    }, this.decay = {
      min: 0.015,
      max: 0.03
    }, this.sound = {
      enabled: false,
      files: [
        "explosion0.mp3",
        "explosion1.mp3",
        "explosion2.mp3"
      ],
      volume: {
        min: 4,
        max: 8
      }
    }, this.boundaries = {
      debug: false,
      height: 0,
      width: 0,
      x: 50,
      y: 50
    };
  }
  update(t) {
    Object.assign(this, v(this, t));
  }
};
var z = class {
  constructor(t, i) {
    __publicField(this, "tick", 0);
    __publicField(this, "rafId", 0);
    __publicField(this, "fps", 60);
    __publicField(this, "tolerance", 0.1);
    __publicField(this, "now");
    this.options = t, this.render = i;
  }
  mount() {
    this.now = performance.now();
    const t = 1e3 / this.fps, i = (s) => {
      this.rafId = requestAnimationFrame(i);
      const n = s - this.now;
      n >= t - this.tolerance && (this.render(), this.now = s - n % t, this.tick += n * (this.options.intensity * Math.PI) / 1e3);
    };
    this.rafId = requestAnimationFrame(i);
  }
  unmount() {
    cancelAnimationFrame(this.rafId);
  }
};
var L = class {
  constructor(t, i, s) {
    __publicField(this, "resizer");
    this.options = t, this.updateSize = i, this.container = s;
  }
  mount() {
    if (!this.resizer) {
      const t = b(() => this.updateSize(), 100);
      this.resizer = new ResizeObserver(t);
    }
    this.options.autoresize && this.resizer.observe(this.container);
  }
  unmount() {
    this.resizer && this.resizer.unobserve(this.container);
  }
};
var M = class {
  constructor(t) {
    __publicField(this, "buffers", []);
    __publicField(this, "audioContext");
    __publicField(this, "onInit", false);
    this.options = t, this.init();
  }
  get isEnabled() {
    return this.options.sound.enabled;
  }
  get soundOptions() {
    return this.options.sound;
  }
  init() {
    !this.onInit && this.isEnabled && (this.onInit = true, this.audioContext = new (window.AudioContext || window.webkitAudioContext)(), this.loadSounds());
  }
  async loadSounds() {
    for (const t of this.soundOptions.files) {
      const i = await (await fetch(t)).arrayBuffer();
      this.audioContext.decodeAudioData(i).then((s) => {
        this.buffers.push(s);
      }).catch((s) => {
        throw s;
      });
    }
  }
  play() {
    if (this.isEnabled && this.buffers.length) {
      const t = this.audioContext.createBufferSource(), i = this.buffers[o(0, this.buffers.length - 1)], s = this.audioContext.createGain();
      t.buffer = i, s.gain.value = c(
        this.soundOptions.volume.min / 100,
        this.soundOptions.volume.max / 100
      ), s.connect(this.audioContext.destination), t.connect(s), t.start(0);
    } else
      this.init();
  }
};
var C = class {
  constructor({
    x: t,
    y: i,
    dx: s,
    dy: n,
    ctx: h,
    hue: a,
    speed: r,
    traceLength: u,
    acceleration: p
  }) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "sx");
    __publicField(this, "sy");
    __publicField(this, "dx");
    __publicField(this, "dy");
    __publicField(this, "ctx");
    __publicField(this, "hue");
    __publicField(this, "speed");
    __publicField(this, "acceleration");
    __publicField(this, "traceLength");
    __publicField(this, "totalDistance");
    __publicField(this, "angle");
    __publicField(this, "brightness");
    __publicField(this, "coordinates", []);
    __publicField(this, "currentDistance", 0);
    for (this.x = t, this.y = i, this.sx = t, this.sy = i, this.dx = s, this.dy = n, this.ctx = h, this.hue = a, this.speed = r, this.traceLength = u, this.acceleration = p, this.totalDistance = m(t, i, s, n), this.angle = Math.atan2(n - i, s - t), this.brightness = o(50, 70); this.traceLength--; )
      this.coordinates.push([t, i]);
  }
  update(t) {
    this.coordinates.pop(), this.coordinates.unshift([this.x, this.y]), this.speed *= this.acceleration;
    const i = Math.cos(this.angle) * this.speed, s = Math.sin(this.angle) * this.speed;
    this.currentDistance = m(
      this.sx,
      this.sy,
      this.x + i,
      this.y + s
    ), this.currentDistance >= this.totalDistance ? t(this.dx, this.dy, this.hue) : (this.x += i, this.y += s);
  }
  draw() {
    const t = this.coordinates.length - 1;
    this.ctx.beginPath(), this.ctx.moveTo(
      this.coordinates[t][0],
      this.coordinates[t][1]
    ), this.ctx.lineTo(this.x, this.y), this.ctx.strokeStyle = x(this.hue, this.brightness), this.ctx.stroke();
  }
};
var T = class {
  constructor(t, i = {}) {
    __publicField(this, "target");
    __publicField(this, "container");
    __publicField(this, "canvas");
    __publicField(this, "ctx");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "traces", []);
    __publicField(this, "explosions", []);
    __publicField(this, "waitStopRaf");
    __publicField(this, "running", false);
    __publicField(this, "opts");
    __publicField(this, "sound");
    __publicField(this, "resize");
    __publicField(this, "mouse");
    __publicField(this, "raf");
    this.target = t, this.container = t, this.opts = new O(), this.createCanvas(this.target), this.updateOptions(i), this.sound = new M(this.opts), this.resize = new L(
      this.opts,
      this.updateSize.bind(this),
      this.container
    ), this.mouse = new E(this.opts, this.canvas), this.raf = new z(this.opts, this.render.bind(this));
  }
  get isRunning() {
    return this.running;
  }
  get version() {
    return "2.10.8";
  }
  get currentOptions() {
    return this.opts;
  }
  start() {
    this.running || (this.canvas.isConnected || this.createCanvas(this.target), this.running = true, this.resize.mount(), this.mouse.mount(), this.raf.mount());
  }
  stop(t = false) {
    this.running && (this.running = false, this.resize.unmount(), this.mouse.unmount(), this.raf.unmount(), this.clear(), t && this.canvas.remove());
  }
  async waitStop(t) {
    if (this.running)
      return new Promise((i) => {
        this.waitStopRaf = () => {
          this.waitStopRaf && (requestAnimationFrame(this.waitStopRaf), !this.traces.length && !this.explosions.length && (this.waitStopRaf = null, this.stop(t), i()));
        }, this.waitStopRaf();
      });
  }
  pause() {
    this.running = !this.running, this.running ? this.raf.mount() : this.raf.unmount();
  }
  clear() {
    this.ctx && (this.traces = [], this.explosions = [], this.ctx.clearRect(0, 0, this.width, this.height));
  }
  launch(t = 1) {
    for (let i = 0; i < t; i++)
      this.createTrace();
    this.waitStopRaf || (this.start(), this.waitStop());
  }
  updateOptions(t) {
    this.opts.update(t);
  }
  updateSize({
    width: t = this.container.clientWidth,
    height: i = this.container.clientHeight
  } = {}) {
    this.width = t, this.height = i, this.canvas.width = t, this.canvas.height = i, this.updateBoundaries({
      ...this.opts.boundaries,
      width: t,
      height: i
    });
  }
  updateBoundaries(t) {
    this.updateOptions({ boundaries: t });
  }
  createCanvas(t) {
    t instanceof HTMLCanvasElement ? (t.isConnected || document.body.append(t), this.canvas = t) : (this.canvas = document.createElement("canvas"), this.container.append(this.canvas)), this.ctx = this.canvas.getContext("2d"), this.updateSize();
  }
  render() {
    if (!this.ctx || !this.running) return;
    const { opacity: t, lineStyle: i, lineWidth: s } = this.opts;
    this.ctx.globalCompositeOperation = "destination-out", this.ctx.fillStyle = `rgba(0, 0, 0, ${t})`, this.ctx.fillRect(0, 0, this.width, this.height), this.ctx.globalCompositeOperation = "lighter", this.ctx.lineCap = i, this.ctx.lineJoin = "round", this.ctx.lineWidth = c(s.trace.min, s.trace.max), this.initTrace(), this.drawTrace(), this.drawExplosion();
  }
  createTrace() {
    const {
      hue: t,
      rocketsPoint: i,
      boundaries: s,
      traceLength: n,
      traceSpeed: h,
      acceleration: a,
      mouse: r
    } = this.opts;
    this.traces.push(
      new C({
        x: this.width * o(i.min, i.max) / 100,
        y: this.height,
        dx: this.mouse.x && r.move || this.mouse.active ? this.mouse.x : o(s.x, s.width - s.x * 2),
        dy: this.mouse.y && r.move || this.mouse.active ? this.mouse.y : o(s.y, s.height * 0.5),
        ctx: this.ctx,
        hue: o(t.min, t.max),
        speed: h,
        acceleration: a,
        traceLength: f(n)
      })
    );
  }
  initTrace() {
    if (this.waitStopRaf) return;
    const { delay: t, mouse: i } = this.opts;
    (this.raf.tick > o(t.min, t.max) || this.mouse.active && i.max > this.traces.length) && (this.createTrace(), this.raf.tick = 0);
  }
  drawTrace() {
    let t = this.traces.length;
    for (; t--; )
      this.traces[t].draw(), this.traces[t].update((i, s, n) => {
        this.initExplosion(i, s, n), this.sound.play(), this.traces.splice(t, 1);
      });
  }
  initExplosion(t, i, s) {
    const {
      particles: n,
      flickering: h,
      lineWidth: a,
      explosion: r,
      brightness: u,
      friction: p,
      gravity: l,
      decay: d
    } = this.opts;
    let w = f(n);
    for (; w--; )
      this.explosions.push(
        new S({
          x: t,
          y: i,
          ctx: this.ctx,
          hue: s,
          friction: p,
          gravity: l,
          flickering: o(0, 100) <= h,
          lineWidth: c(
            a.explosion.min,
            a.explosion.max
          ),
          explosionLength: f(r),
          brightness: u,
          decay: d
        })
      );
  }
  drawExplosion() {
    let t = this.explosions.length;
    for (; t--; )
      this.explosions[t].draw(), this.explosions[t].update(() => {
        this.explosions.splice(t, 1);
      });
  }
};
export {
  T as Fireworks,
  T as default
};
//# sourceMappingURL=fireworks-js.js.map
