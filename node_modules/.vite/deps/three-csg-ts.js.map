{
  "version": 3,
  "sources": ["../../three-csg-ts/lib/esm/NBuf.js", "../../three-csg-ts/lib/esm/Node.js", "../../three-csg-ts/lib/esm/Vector.js", "../../three-csg-ts/lib/esm/Plane.js", "../../three-csg-ts/lib/esm/Polygon.js", "../../three-csg-ts/lib/esm/Vertex.js", "../../three-csg-ts/lib/esm/CSG.js"],
  "sourcesContent": ["export class NBuf3 {\n    constructor(ct) {\n        this.top = 0;\n        this.array = new Float32Array(ct);\n    }\n    write(v) {\n        this.array[this.top++] = v.x;\n        this.array[this.top++] = v.y;\n        this.array[this.top++] = v.z;\n    }\n}\nexport class NBuf2 {\n    constructor(ct) {\n        this.top = 0;\n        this.array = new Float32Array(ct);\n    }\n    write(v) {\n        this.array[this.top++] = v.x;\n        this.array[this.top++] = v.y;\n    }\n}\n", "/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes.\n */\nexport class Node {\n    constructor(polygons) {\n        this.plane = null;\n        this.front = null;\n        this.back = null;\n        this.polygons = [];\n        if (polygons)\n            this.build(polygons);\n    }\n    clone() {\n        const node = new Node();\n        node.plane = this.plane && this.plane.clone();\n        node.front = this.front && this.front.clone();\n        node.back = this.back && this.back.clone();\n        node.polygons = this.polygons.map((p) => p.clone());\n        return node;\n    }\n    // Convert solid space to empty space and empty space to solid space.\n    invert() {\n        for (let i = 0; i < this.polygons.length; i++)\n            this.polygons[i].flip();\n        this.plane && this.plane.flip();\n        this.front && this.front.invert();\n        this.back && this.back.invert();\n        const temp = this.front;\n        this.front = this.back;\n        this.back = temp;\n    }\n    // Recursively remove all polygons in `polygons` that are inside this BSP\n    // tree.\n    clipPolygons(polygons) {\n        if (!this.plane)\n            return polygons.slice();\n        let front = new Array(), back = new Array();\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\n        }\n        if (this.front)\n            front = this.front.clipPolygons(front);\n        this.back ? (back = this.back.clipPolygons(back)) : (back = []);\n        return front.concat(back);\n    }\n    // Remove all polygons in this BSP tree that are inside the other BSP tree\n    // `bsp`.\n    clipTo(bsp) {\n        this.polygons = bsp.clipPolygons(this.polygons);\n        if (this.front)\n            this.front.clipTo(bsp);\n        if (this.back)\n            this.back.clipTo(bsp);\n    }\n    // Return a list of all polygons in this BSP tree.\n    allPolygons() {\n        let polygons = this.polygons.slice();\n        if (this.front)\n            polygons = polygons.concat(this.front.allPolygons());\n        if (this.back)\n            polygons = polygons.concat(this.back.allPolygons());\n        return polygons;\n    }\n    // Build a BSP tree out of `polygons`. When called on an existing tree, the\n    // new polygons are filtered down to the bottom of the tree and become new\n    // nodes there. Each set of polygons is partitioned using the first polygon\n    // (no heuristic is used to pick a good split).\n    build(polygons) {\n        if (!polygons.length)\n            return;\n        if (!this.plane)\n            this.plane = polygons[0].plane.clone();\n        const front = [], back = [];\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n        }\n        if (front.length) {\n            if (!this.front)\n                this.front = new Node();\n            this.front.build(front);\n        }\n        if (back.length) {\n            if (!this.back)\n                this.back = new Node();\n            this.back.build(back);\n        }\n    }\n}\n", "import { Vector3 } from 'three';\n/**\n * Represents a 3D vector.\n */\nexport class Vector {\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        return this;\n    }\n    clone() {\n        return new Vector(this.x, this.y, this.z);\n    }\n    negate() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    }\n    add(a) {\n        this.x += a.x;\n        this.y += a.y;\n        this.z += a.z;\n        return this;\n    }\n    sub(a) {\n        this.x -= a.x;\n        this.y -= a.y;\n        this.z -= a.z;\n        return this;\n    }\n    times(a) {\n        this.x *= a;\n        this.y *= a;\n        this.z *= a;\n        return this;\n    }\n    dividedBy(a) {\n        this.x /= a;\n        this.y /= a;\n        this.z /= a;\n        return this;\n    }\n    lerp(a, t) {\n        return this.add(new Vector().copy(a).sub(this).times(t));\n    }\n    unit() {\n        return this.dividedBy(this.length());\n    }\n    length() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\n    }\n    normalize() {\n        return this.unit();\n    }\n    cross(b) {\n        const a = this.clone();\n        const ax = a.x, ay = a.y, az = a.z;\n        const bx = b.x, by = b.y, bz = b.z;\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n        return this;\n    }\n    dot(b) {\n        return this.x * b.x + this.y * b.y + this.z * b.z;\n    }\n    toVector3() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n}\n", "import { Polygon } from './Polygon';\nimport { Vector } from './Vector';\n/**\n * Represents a plane in 3D space.\n */\nexport class Plane {\n    constructor(normal, w) {\n        this.normal = normal;\n        this.w = w;\n        this.normal = normal;\n        this.w = w;\n    }\n    clone() {\n        return new Plane(this.normal.clone(), this.w);\n    }\n    flip() {\n        this.normal.negate();\n        this.w = -this.w;\n    }\n    // Split `polygon` by this plane if needed, then put the polygon or polygon\n    // fragments in the appropriate lists. Coplanar polygons go into either\n    // `coplanarFront` or `coplanarBack` depending on their orientation with\n    // respect to this plane. Polygons in front or in back of this plane go into\n    // either `front` or `back`.\n    splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\n        const COPLANAR = 0;\n        const FRONT = 1;\n        const BACK = 2;\n        const SPANNING = 3;\n        // Classify each point as well as the entire polygon into one of the above\n        // four classes.\n        let polygonType = 0;\n        const types = [];\n        for (let i = 0; i < polygon.vertices.length; i++) {\n            const t = this.normal.dot(polygon.vertices[i].pos) - this.w;\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n            polygonType |= type;\n            types.push(type);\n        }\n        // Put the polygon in the correct list, splitting it when necessary.\n        switch (polygonType) {\n            case COPLANAR:\n                (this.normal.dot(polygon.plane.normal) > 0\n                    ? coplanarFront\n                    : coplanarBack).push(polygon);\n                break;\n            case FRONT:\n                front.push(polygon);\n                break;\n            case BACK:\n                back.push(polygon);\n                break;\n            case SPANNING: {\n                const f = [], b = [];\n                for (let i = 0; i < polygon.vertices.length; i++) {\n                    const j = (i + 1) % polygon.vertices.length;\n                    const ti = types[i], tj = types[j];\n                    const vi = polygon.vertices[i], vj = polygon.vertices[j];\n                    if (ti != BACK)\n                        f.push(vi);\n                    if (ti != FRONT)\n                        b.push(ti != BACK ? vi.clone() : vi);\n                    if ((ti | tj) == SPANNING) {\n                        const t = (this.w - this.normal.dot(vi.pos)) /\n                            this.normal.dot(new Vector().copy(vj.pos).sub(vi.pos));\n                        const v = vi.interpolate(vj, t);\n                        f.push(v);\n                        b.push(v.clone());\n                    }\n                }\n                if (f.length >= 3)\n                    front.push(new Polygon(f, polygon.shared));\n                if (b.length >= 3)\n                    back.push(new Polygon(b, polygon.shared));\n                break;\n            }\n        }\n    }\n    static fromPoints(a, b, c) {\n        const n = new Vector()\n            .copy(b)\n            .sub(a)\n            .cross(new Vector().copy(c).sub(a))\n            .normalize();\n        return new Plane(n.clone(), n.dot(a));\n    }\n}\nPlane.EPSILON = 1e-5;\n", "import { Plane } from './Plane';\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop. They do not have to be `Vertex`\n * instances but they must behave similarly (duck typing can be used for\n * customization).\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color).\n */\nexport class Polygon {\n    constructor(vertices, shared) {\n        this.vertices = vertices;\n        this.shared = shared;\n        this.plane = Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n    }\n    clone() {\n        return new Polygon(this.vertices.map((v) => v.clone()), this.shared);\n    }\n    flip() {\n        this.vertices.reverse().map((v) => v.flip());\n        this.plane.flip();\n    }\n}\n", "import { Vector } from './Vector';\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `CSG.Vertex`. This class provides `normal` so convenience\n * functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n */\nexport class Vertex {\n    constructor(pos, normal, uv, color) {\n        this.pos = new Vector().copy(pos);\n        this.normal = new Vector().copy(normal);\n        this.uv = new Vector().copy(uv);\n        this.uv.z = 0;\n        color && (this.color = new Vector().copy(color));\n    }\n    clone() {\n        return new Vertex(this.pos, this.normal, this.uv, this.color);\n    }\n    // Invert all orientation-specific data (e.g. vertex normal). Called when the\n    // orientation of a polygon is flipped.\n    flip() {\n        this.normal.negate();\n    }\n    // Create a new vertex between this vertex and `other` by linearly\n    // interpolating all properties using a parameter of `t`. Subclasses should\n    // override this to interpolate additional properties.\n    interpolate(other, t) {\n        return new Vertex(this.pos.clone().lerp(other.pos, t), this.normal.clone().lerp(other.normal, t), this.uv.clone().lerp(other.uv, t), this.color && other.color && this.color.clone().lerp(other.color, t));\n    }\n}\n", "import { BufferAttribute, BufferGeometry, Matrix3, Matrix4, Mesh, Vector3, } from 'three';\nimport { NBuf2, NBuf3 } from './NBuf';\nimport { Node } from './Node';\nimport { Polygon } from './Polygon';\nimport { Vector } from './Vector';\nimport { Vertex } from './Vertex';\n/**\n * Holds a binary space partition tree representing a 3D solid. Two solids can\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\n */\nexport class CSG {\n    constructor() {\n        this.polygons = [];\n    }\n    static fromPolygons(polygons) {\n        const csg = new CSG();\n        csg.polygons = polygons;\n        return csg;\n    }\n    static fromGeometry(geom, objectIndex) {\n        let polys = [];\n        const posattr = geom.attributes.position;\n        const normalattr = geom.attributes.normal;\n        const uvattr = geom.attributes.uv;\n        const colorattr = geom.attributes.color;\n        const grps = geom.groups;\n        let index;\n        if (geom.index) {\n            index = geom.index.array;\n        }\n        else {\n            index = new Uint16Array((posattr.array.length / posattr.itemSize) | 0);\n            for (let i = 0; i < index.length; i++)\n                index[i] = i;\n        }\n        const triCount = (index.length / 3) | 0;\n        polys = new Array(triCount);\n        for (let i = 0, pli = 0, l = index.length; i < l; i += 3, pli++) {\n            const vertices = new Array(3);\n            for (let j = 0; j < 3; j++) {\n                const vi = index[i + j];\n                const vp = vi * 3;\n                const vt = vi * 2;\n                const x = posattr.array[vp];\n                const y = posattr.array[vp + 1];\n                const z = posattr.array[vp + 2];\n                const nx = normalattr.array[vp];\n                const ny = normalattr.array[vp + 1];\n                const nz = normalattr.array[vp + 2];\n                const u = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt];\n                const v = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt + 1];\n                vertices[j] = new Vertex(new Vector(x, y, z), new Vector(nx, ny, nz), new Vector(u, v, 0), colorattr &&\n                    new Vector(colorattr.array[vp], colorattr.array[vp + 1], colorattr.array[vp + 2]));\n            }\n            if (objectIndex === undefined && grps && grps.length > 0) {\n                for (const grp of grps) {\n                    if (i >= grp.start && i < grp.start + grp.count) {\n                        polys[pli] = new Polygon(vertices, grp.materialIndex);\n                    }\n                }\n            }\n            else {\n                polys[pli] = new Polygon(vertices, objectIndex);\n            }\n        }\n        return CSG.fromPolygons(polys.filter((p) => !Number.isNaN(p.plane.normal.x)));\n    }\n    static toGeometry(csg, toMatrix) {\n        let triCount = 0;\n        const ps = csg.polygons;\n        for (const p of ps) {\n            triCount += p.vertices.length - 2;\n        }\n        const geom = new BufferGeometry();\n        const vertices = new NBuf3(triCount * 3 * 3);\n        const normals = new NBuf3(triCount * 3 * 3);\n        const uvs = new NBuf2(triCount * 2 * 3);\n        let colors;\n        const grps = [];\n        const dgrp = [];\n        for (const p of ps) {\n            const pvs = p.vertices;\n            const pvlen = pvs.length;\n            if (p.shared !== undefined) {\n                if (!grps[p.shared])\n                    grps[p.shared] = [];\n            }\n            if (pvlen && pvs[0].color !== undefined) {\n                if (!colors)\n                    colors = new NBuf3(triCount * 3 * 3);\n            }\n            for (let j = 3; j <= pvlen; j++) {\n                const grp = p.shared === undefined ? dgrp : grps[p.shared];\n                grp.push(vertices.top / 3, vertices.top / 3 + 1, vertices.top / 3 + 2);\n                vertices.write(pvs[0].pos);\n                vertices.write(pvs[j - 2].pos);\n                vertices.write(pvs[j - 1].pos);\n                normals.write(pvs[0].normal);\n                normals.write(pvs[j - 2].normal);\n                normals.write(pvs[j - 1].normal);\n                if (uvs) {\n                    uvs.write(pvs[0].uv);\n                    uvs.write(pvs[j - 2].uv);\n                    uvs.write(pvs[j - 1].uv);\n                }\n                if (colors) {\n                    colors.write(pvs[0].color);\n                    colors.write(pvs[j - 2].color);\n                    colors.write(pvs[j - 1].color);\n                }\n            }\n        }\n        geom.setAttribute('position', new BufferAttribute(vertices.array, 3));\n        geom.setAttribute('normal', new BufferAttribute(normals.array, 3));\n        uvs && geom.setAttribute('uv', new BufferAttribute(uvs.array, 2));\n        colors && geom.setAttribute('color', new BufferAttribute(colors.array, 3));\n        for (let gi = 0; gi < grps.length; gi++) {\n            if (grps[gi] === undefined) {\n                grps[gi] = [];\n            }\n        }\n        if (grps.length) {\n            let index = [];\n            let gbase = 0;\n            for (let gi = 0; gi < grps.length; gi++) {\n                geom.addGroup(gbase, grps[gi].length, gi);\n                gbase += grps[gi].length;\n                index = index.concat(grps[gi]);\n            }\n            geom.addGroup(gbase, dgrp.length, grps.length);\n            index = index.concat(dgrp);\n            geom.setIndex(index);\n        }\n        const inv = new Matrix4().copy(toMatrix).invert();\n        geom.applyMatrix4(inv);\n        geom.computeBoundingSphere();\n        geom.computeBoundingBox();\n        return geom;\n    }\n    static fromMesh(mesh, objectIndex) {\n        const csg = CSG.fromGeometry(mesh.geometry, objectIndex);\n        const ttvv0 = new Vector3();\n        const tmpm3 = new Matrix3();\n        tmpm3.getNormalMatrix(mesh.matrix);\n        for (let i = 0; i < csg.polygons.length; i++) {\n            const p = csg.polygons[i];\n            for (let j = 0; j < p.vertices.length; j++) {\n                const v = p.vertices[j];\n                v.pos.copy(ttvv0.copy(v.pos.toVector3()).applyMatrix4(mesh.matrix));\n                v.normal.copy(ttvv0.copy(v.normal.toVector3()).applyMatrix3(tmpm3));\n            }\n        }\n        return csg;\n    }\n    static toMesh(csg, toMatrix, toMaterial) {\n        const geom = CSG.toGeometry(csg, toMatrix);\n        const m = new Mesh(geom, toMaterial);\n        m.matrix.copy(toMatrix);\n        m.matrix.decompose(m.position, m.quaternion, m.scale);\n        m.rotation.setFromQuaternion(m.quaternion);\n        m.updateMatrixWorld();\n        m.castShadow = m.receiveShadow = true;\n        return m;\n    }\n    static union(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.union(csgB), meshA.matrix, meshA.material);\n    }\n    static subtract(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.subtract(csgB), meshA.matrix, meshA.material);\n    }\n    static intersect(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.intersect(csgB), meshA.matrix, meshA.material);\n    }\n    clone() {\n        const csg = new CSG();\n        csg.polygons = this.polygons\n            .map((p) => p.clone())\n            .filter((p) => Number.isFinite(p.plane.w));\n        return csg;\n    }\n    toPolygons() {\n        return this.polygons;\n    }\n    union(csg) {\n        const a = new Node(this.clone().polygons);\n        const b = new Node(csg.clone().polygons);\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    subtract(csg) {\n        const a = new Node(this.clone().polygons);\n        const b = new Node(csg.clone().polygons);\n        a.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    intersect(csg) {\n        const a = new Node(this.clone().polygons);\n        const b = new Node(csg.clone().polygons);\n        a.invert();\n        b.clipTo(a);\n        b.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    // Return a new CSG solid with solid and empty space switched. This solid is\n    // not modified.\n    inverse() {\n        const csg = this.clone();\n        for (const p of csg.polygons) {\n            p.flip();\n        }\n        return csg;\n    }\n    toMesh(toMatrix, toMaterial) {\n        return CSG.toMesh(this, toMatrix, toMaterial);\n    }\n    toGeometry(toMatrix) {\n        return CSG.toGeometry(this, toMatrix);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
